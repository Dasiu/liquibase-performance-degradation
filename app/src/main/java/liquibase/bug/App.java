/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package liquibase.bug;

import static java.sql.DriverManager.getConnection;

import liquibase.Liquibase;
import liquibase.Scope;
import liquibase.ThreadLocalScopeManager;
import liquibase.changelog.ChangeLogHistoryServiceFactory;
import liquibase.changelog.DatabaseChangeLog;
import liquibase.configuration.LiquibaseConfiguration;
import liquibase.configuration.core.EnvironmentValueProvider;
import liquibase.configuration.core.SystemPropertyValueProvider;
import liquibase.database.Database;
import liquibase.database.DatabaseFactory;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.DatabaseException;
import liquibase.exception.LiquibaseException;
import liquibase.executor.ExecutorService;
import liquibase.lockservice.LockServiceFactory;
import liquibase.resource.ClassLoaderResourceAccessor;
import liquibase.resource.ResourceAccessor;

import java.io.FileNotFoundException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class App {

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        Scope.setScopeManager(new ThreadLocalScopeManager());
        var singleton = Scope.getCurrentScope().getSingleton(LiquibaseConfiguration.class);
        // those providers create threads congestion but since I don't need them and there is a way to disable them, so I did
        singleton.getProviders().stream().toList().stream()
                .filter(config -> (config instanceof EnvironmentValueProvider) || (config instanceof SystemPropertyValueProvider))
                .forEach(singleton::unregisterProvider);

        ThreadLocal<Map<String, DatabaseChangeLog>> changelogCache = ThreadLocal.withInitial(HashMap::new);
        var executor = Executors.newFixedThreadPool(4);
        var futures = IntStream.rangeClosed(1, 200)
                .mapToObj(id -> "test_" + id)
                .map(schema -> CompletableFuture.runAsync(() -> migrate(schema, changelogCache.get()), executor))
                .toArray(CompletableFuture[]::new);

        CompletableFuture.allOf(futures).get();
        executor.shutdown();
    }

    private static void migrate(String schema, Map<String, DatabaseChangeLog> changelogCache) {
        try (Connection connection = getConnection("jdbc:mysql://localhost:3306,", "root", "root")) {
            var path = "master.changelog.xml";
            var resourceAccessor = new ClassLoaderResourceAccessor(App.class.getClassLoader());
            var databaseChangeLog = changelogCache.computeIfAbsent(
                    path,
                    p -> {
                        var database = database(connection);
                        return databaseChangeLog(path, resourceAccessor, database);
                    }
            );

            // schema creation could be commented out in the next run once schemas are migrated
            var createSchema = "CREATE SCHEMA IF NOT EXISTS " + schema;
            connection.createStatement().execute(createSchema);

            connection.setCatalog(schema);

            var database = database(connection);

            var liquibase = new CustomLiquibase(databaseChangeLog, resourceAccessor, database);

            liquibase.update();
        } catch (SQLException | LiquibaseException e) {
            throw new RuntimeException(e);
        }
    }

    private static DatabaseChangeLog databaseChangeLog(String path, ClassLoaderResourceAccessor resourceAccessor, Database database) {
        try {
            return new CustomLiquibase(path, resourceAccessor, database).getDatabaseChangeLog();
        } catch (LiquibaseException e) {
            throw new RuntimeException( e);
        }
    }

    private static Database database(Connection connection) {
        try {
            return DatabaseFactory.getInstance().findCorrectDatabaseImplementation(new JdbcConnection(connection));
        } catch (DatabaseException e) {
            throw new RuntimeException(e);
        }
    }

}

// see https://liquibase.jira.com/browse/CORE-2792
class CustomLiquibase extends Liquibase {

    public CustomLiquibase(String changeLogFile, ResourceAccessor resourceAccessor, Database database) {
        super(changeLogFile, resourceAccessor, database);
    }

    public CustomLiquibase(DatabaseChangeLog changeLog, ResourceAccessor resourceAccessor, Database database) {
        super(changeLog, resourceAccessor, database);
    }

    @Override
    protected void resetServices() {
        LockServiceFactory.getInstance().getLockService(database).reset();
        ChangeLogHistoryServiceFactory.getInstance().getChangeLogService(database).reset();
        Scope.getCurrentScope().getSingleton(ExecutorService.class).reset();
    }

}
